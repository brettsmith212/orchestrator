package core

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/brettsmith212/orchestrator/internal/protocol"
)

// ResourceLimits defines the maximum resources an agent can use
type ResourceLimits struct {
	// MaxTokens is the maximum number of tokens an agent can consume
	MaxTokens int

	// MaxDuration is the maximum time an agent can run
	MaxDuration time.Duration
}

// DefaultLimits provides sensible defaults for resource limits
var DefaultLimits = ResourceLimits{
	MaxTokens:   10000, // 10K tokens by default
	MaxDuration: 5 * time.Minute,
}

// TokenCounter tracks token usage for a specific agent
type TokenCounter struct {
	// AgentID identifies the agent being monitored
	AgentID string

	// InputTokens counts tokens used in prompts/inputs
	InputTokens int

	// OutputTokens counts tokens generated by the agent
	OutputTokens int

	// StartTime records when monitoring began
	StartTime time.Time

	// LastActivity records the last time we received an event
	LastActivity time.Time
}

// TotalTokens returns the sum of input and output tokens
func (tc *TokenCounter) TotalTokens() int {
	return tc.InputTokens + tc.OutputTokens
}

// Duration returns how long the agent has been running
func (tc *TokenCounter) Duration() time.Duration {
	return time.Since(tc.StartTime)
}

// TimeSinceLastActivity returns time since the last activity
func (tc *TokenCounter) TimeSinceLastActivity() time.Duration {
	return time.Since(tc.LastActivity)
}

// Watchdog monitors agent resource usage and enforces limits
type Watchdog struct {
	mutex    sync.Mutex
	limits   ResourceLimits
	counters map[string]*TokenCounter
	warnings map[string]bool // Tracks if we've sent a warning for an agent
}

// NewWatchdog creates a new resource usage watchdog
func NewWatchdog(limits ResourceLimits) *Watchdog {
	return &Watchdog{
		limits:   limits,
		counters: make(map[string]*TokenCounter),
		warnings: make(map[string]bool),
	}
}

// MonitorAgent starts tracking resource usage for an agent
func (w *Watchdog) MonitorAgent(agentID string) {
	w.mutex.Lock()
	defer w.mutex.Unlock()

	w.counters[agentID] = &TokenCounter{
		AgentID:      agentID,
		StartTime:    time.Now(),
		LastActivity: time.Now(),
	}
}

// TrackEvent processes an agent event to update resource usage
func (w *Watchdog) TrackEvent(event *protocol.Event) {
	if event == nil || event.AgentID == "" {
		return // Skip events without agent ID
	}

	w.mutex.Lock()
	defer w.mutex.Unlock()

	// Get or create counter for this agent
	counter, exists := w.counters[event.AgentID]
	if !exists {
		// Start monitoring this agent if we weren't already
		counter = &TokenCounter{
			AgentID:      event.AgentID,
			StartTime:    time.Now(),
			LastActivity: time.Now(),
		}
		w.counters[event.AgentID] = counter
	}

	// Update last activity time
	counter.LastActivity = time.Now()

	// Extract token usage from event if available
	tokenCount := extractTokenCount(event)
	if tokenCount > 0 {
		// Assume it's output tokens for now (could be refined based on event type)
		counter.OutputTokens += tokenCount
	}
}

// CheckLimits checks if any agent has exceeded its resource limits
// It returns the IDs of agents that should be terminated
func (w *Watchdog) CheckLimits() []string {
	w.mutex.Lock()
	defer w.mutex.Unlock()

	var agentsToStop []string

	for agentID, counter := range w.counters {
		// Check token limit
		if counter.TotalTokens() > w.limits.MaxTokens {
			agentsToStop = append(agentsToStop, agentID)
			continue
		}

		// Check duration limit
		if counter.Duration() > w.limits.MaxDuration {
			agentsToStop = append(agentsToStop, agentID)
			continue
		}
	}

	return agentsToStop
}

// GetWarningEvents generates warning events for agents approaching limits
func (w *Watchdog) GetWarningEvents() []*protocol.Event {
	w.mutex.Lock()
	defer w.mutex.Unlock()

	var warnings []*protocol.Event
	warningThreshold := 0.8 // 80% of limit

	for agentID, counter := range w.counters {
		// Skip agents we've already warned
		if w.warnings[agentID] {
			continue
		}

		// Check token limit threshold
		tokenThreshold := int(float64(w.limits.MaxTokens) * warningThreshold)
		if counter.TotalTokens() > tokenThreshold {
			// Create warning event
			event := protocol.NewEvent(protocol.EventTypeWatchdog, "", 0)

			payload := map[string]interface{}{
				"target_agent_id": agentID,
				"message":        fmt.Sprintf("Approaching token limit: %d/%d tokens used", counter.TotalTokens(), w.limits.MaxTokens),
				"resource":       "tokens",
				"current":        counter.TotalTokens(),
				"limit":          w.limits.MaxTokens,
			}

			event, _ = event.WithPayload(payload)
			warnings = append(warnings, event)
			w.warnings[agentID] = true
			continue
		}

		// Check time limit threshold
		timeThreshold := time.Duration(float64(w.limits.MaxDuration) * warningThreshold)
		if counter.Duration() > timeThreshold {
			// Create warning event
			event := protocol.NewEvent(protocol.EventTypeWatchdog, "", 0)

			payload := map[string]interface{}{
				"target_agent_id": agentID,
				"message":        fmt.Sprintf("Approaching time limit: %v/%v elapsed", counter.Duration().Round(time.Second), w.limits.MaxDuration),
				"resource":       "time",
				"current":        counter.Duration().Seconds(),
				"limit":          w.limits.MaxDuration.Seconds(),
			}

			event, _ = event.WithPayload(payload)
			warnings = append(warnings, event)
			w.warnings[agentID] = true
		}
	}

	return warnings
}

// GetUsage returns the current resource usage for all agents
func (w *Watchdog) GetUsage() map[string]*TokenCounter {
	w.mutex.Lock()
	defer w.mutex.Unlock()

	// Create a copy to avoid exposing the internal map
	result := make(map[string]*TokenCounter, len(w.counters))
	for id, counter := range w.counters {
		copied := *counter // Make a copy of the counter
		result[id] = &copied
	}

	return result
}

// StopMonitoring removes an agent from monitoring
func (w *Watchdog) StopMonitoring(agentID string) {
	w.mutex.Lock()
	defer w.mutex.Unlock()

	delete(w.counters, agentID)
	delete(w.warnings, agentID)
}

// RunPeriodicCheck starts a goroutine that periodically checks resource limits
// It sends warnings and termination signals via the provided channels
func (w *Watchdog) RunPeriodicCheck(ctx context.Context, checkInterval time.Duration, warningCh chan<- *protocol.Event, terminateCh chan<- string) {
	ticker := time.NewTicker(checkInterval)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			// Check for warnings first
			warnings := w.GetWarningEvents()
			for _, event := range warnings {
				select {
				case warningCh <- event:
					// Successfully sent warning
				default:
					// Channel full or closed, skip warning
				}
			}

			// Then check for terminations
			agentsToStop := w.CheckLimits()
			for _, agentID := range agentsToStop {
				select {
				case terminateCh <- agentID:
					// Successfully sent termination signal
					// Stop monitoring this agent
					w.StopMonitoring(agentID)
				default:
					// Channel full or closed, skip termination
				}
			}
		case <-ctx.Done():
			return
		}
	}
}

// extractTokenCount attempts to extract token usage from an event
func extractTokenCount(event *protocol.Event) int {
	// For Claude events, check the Claude-specific payload structure
	if event.AgentID == "claude" {
		// Claude event format example (hypothetical):
		// {"token_count": 123, ... }
		return extractClaudeTokenCount(event)
	}

	// For Amp events, check the Amp-specific payload structure
	if event.AgentID == "amp" {
		// Amp event format example (hypothetical):
		// {"usage": {"total_tokens": 456}, ... }
		return extractAmpTokenCount(event)
	}

	// For Codex events, check the Codex-specific payload structure
	if event.AgentID == "codex" {
		// Codex event format example (hypothetical):
		// {"usage": {"completion_tokens": 789}, ... }
		return extractCodexTokenCount(event)
	}

	// Default case: no token count available
	return 0
}

// extractClaudeTokenCount parses Claude-specific event format
func extractClaudeTokenCount(event *protocol.Event) int {
	// This implementation depends on the actual structure of Claude events
	// For now, we just return a placeholder
	return 0
}

// extractAmpTokenCount parses Amp-specific event format
func extractAmpTokenCount(event *protocol.Event) int {
	// This implementation depends on the actual structure of Amp events
	// For now, we just return a placeholder
	return 0
}

// extractCodexTokenCount parses Codex-specific event format
func extractCodexTokenCount(event *protocol.Event) int {
	// This implementation depends on the actual structure of Codex events
	// For now, we just return a placeholder
	return 0
}